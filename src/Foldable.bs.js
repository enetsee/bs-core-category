// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Bool$CoreCategory = require("./Bool.bs.js");

function S_to_S2(X) {
  return {
          foldLeft: X.foldLeft,
          foldRight: X.foldRight,
          foldMap: X.foldMap,
          exists: X.exists,
          forall: X.forall,
          find: X.find
        };
}

function S2_to_S(X) {
  return {
          foldLeft: X.foldLeft,
          foldRight: X.foldRight,
          foldMap: X.foldMap,
          exists: X.exists,
          forall: X.forall,
          find: X.find
        };
}

function S2_to_S3(X) {
  return {
          foldLeft: X.foldLeft,
          foldRight: X.foldRight,
          foldMap: X.foldMap,
          exists: X.exists,
          forall: X.forall,
          find: X.find
        };
}

function S3_to_S2(X) {
  return {
          foldLeft: X.foldLeft,
          foldRight: X.foldRight,
          foldMap: X.foldMap,
          exists: X.exists,
          forall: X.forall,
          find: X.find
        };
}

function Make3(X) {
  var foldLeft = X.foldLeft;
  var foldRight = function (x, f, init) {
    var f$prime = function (k, x, z) {
      return Curry._1(k, Curry._2(f, x, z));
    };
    return Curry._4(foldLeft, x, f$prime, (function (x) {
                  return x;
                }), init);
  };
  var foldMap = function (M, $staropt$star, x, f) {
    var empty = $staropt$star !== undefined ? Caml_option.valFromOption($staropt$star) : M.empty;
    return foldRight(x, (function (x, accu) {
                  return Curry._2(M.combine, accu, Curry._1(f, x));
                }), empty);
  };
  var exists = function (init, x, pred) {
    return foldMap(Bool$CoreCategory.Or, init, x, pred);
  };
  var forall = function (init, x, pred) {
    return foldMap(Bool$CoreCategory.And, init, x, pred);
  };
  var find = function (x, pred) {
    return foldRight(x, (function (x, accu) {
                  if (accu !== undefined) {
                    return accu;
                  } else if (Curry._1(pred, x)) {
                    return Caml_option.some(x);
                  } else {
                    return ;
                  }
                }), undefined);
  };
  return {
          foldLeft: foldLeft,
          foldRight: foldRight,
          foldMap: foldMap,
          exists: exists,
          forall: forall,
          find: find
        };
}

function Make2(X) {
  var foldLeft = X.foldLeft;
  var foldRight = function (x, f, init) {
    var f$prime = function (k, x, z) {
      return Curry._1(k, Curry._2(f, x, z));
    };
    return Curry._4(foldLeft, x, f$prime, (function (x) {
                  return x;
                }), init);
  };
  var foldMap = function (M, $staropt$star, x, f) {
    var empty = $staropt$star !== undefined ? Caml_option.valFromOption($staropt$star) : M.empty;
    return foldRight(x, (function (x, accu) {
                  return Curry._2(M.combine, accu, Curry._1(f, x));
                }), empty);
  };
  var exists = function (init, x, pred) {
    return foldMap(Bool$CoreCategory.Or, init, x, pred);
  };
  var forall = function (init, x, pred) {
    return foldMap(Bool$CoreCategory.And, init, x, pred);
  };
  var find = function (x, pred) {
    return foldRight(x, (function (x, accu) {
                  if (accu !== undefined) {
                    return accu;
                  } else if (Curry._1(pred, x)) {
                    return Caml_option.some(x);
                  } else {
                    return ;
                  }
                }), undefined);
  };
  return {
          foldLeft: foldLeft,
          foldRight: foldRight,
          foldMap: foldMap,
          exists: exists,
          forall: forall,
          find: find
        };
}

function Make(X) {
  var foldLeft = X.foldLeft;
  var foldRight = function (x, f, init) {
    var f$prime = function (k, x, z) {
      return Curry._1(k, Curry._2(f, x, z));
    };
    return Curry._4(foldLeft, x, f$prime, (function (x) {
                  return x;
                }), init);
  };
  var foldMap = function (M, $staropt$star, x, f) {
    var empty = $staropt$star !== undefined ? Caml_option.valFromOption($staropt$star) : M.empty;
    return foldRight(x, (function (x, accu) {
                  return Curry._2(M.combine, accu, Curry._1(f, x));
                }), empty);
  };
  var exists = function (init, x, pred) {
    return foldMap(Bool$CoreCategory.Or, init, x, pred);
  };
  var forall = function (init, x, pred) {
    return foldMap(Bool$CoreCategory.And, init, x, pred);
  };
  var find = function (x, pred) {
    return foldRight(x, (function (x, accu) {
                  if (accu !== undefined) {
                    return accu;
                  } else if (Curry._1(pred, x)) {
                    return Caml_option.some(x);
                  } else {
                    return ;
                  }
                }), undefined);
  };
  return {
          foldLeft: foldLeft,
          foldRight: foldRight,
          foldMap: foldMap,
          exists: exists,
          forall: forall,
          find: find
        };
}

exports.S_to_S2 = S_to_S2;
exports.S2_to_S = S2_to_S;
exports.S2_to_S3 = S2_to_S3;
exports.S3_to_S2 = S3_to_S2;
exports.Make3 = Make3;
exports.Make2 = Make2;
exports.Make = Make;
/* Bool-CoreCategory Not a pure module */
