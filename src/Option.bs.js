// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Monad$CoreCategory = require("./Monad.bs.js");
var Applicative$CoreCategory = require("./Applicative.bs.js");

var option = Belt_Option.mapWithDefault;

function some(t) {
  return Caml_option.some(t);
}

var map_001 = Belt_Option.map;

var map = /* `Custom */[
  -198771759,
  map_001
];

function $$return(x) {
  return Caml_option.some(x);
}

function apply_001(x, f) {
  if (f !== undefined && x !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(x)));
  }
  
}

var apply = /* `Custom */[
  -198771759,
  apply_001
];

function bind(x, f) {
  if (x !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(x));
  }
  
}

var include = Monad$CoreCategory.Make({
      $$return: $$return,
      bind: bind,
      apply: apply,
      map: map,
      liftA2: /* Using_apply */524559571,
      liftA3: /* Using_apply */524559571,
      discardFirst: /* Using_apply */524559571,
      discardSecond: /* Using_apply */524559571,
      select: /* Using_bind */301992440
    });

function map2(t1, t2, f) {
  if (t1 !== undefined && t2 !== undefined) {
    return Caml_option.some(Curry._2(f, Caml_option.valFromOption(t1), Caml_option.valFromOption(t2)));
  }
  
}

function Make3(F) {
  var traverse = function (t, f) {
    if (t !== undefined) {
      var func = F.map;
      return (function (param) {
                  return Curry._2(func, param, some);
                })(Curry._1(f, Caml_option.valFromOption(t)));
    } else {
      return Curry._1(F.$$return, undefined);
    }
  };
  return {
          traverse: traverse
        };
}

function Make2(F) {
  var F$1 = Applicative$CoreCategory.S2_to_S3(F);
  var traverse = function (t, f) {
    if (t !== undefined) {
      var func = F$1.map;
      return (function (param) {
                  return Curry._2(func, param, some);
                })(Curry._1(f, Caml_option.valFromOption(t)));
    } else {
      return Curry._1(F$1.$$return, undefined);
    }
  };
  return {
          traverse: traverse
        };
}

function Make(F) {
  var F$1 = Applicative$CoreCategory.S_to_S2(F);
  var F$2 = Applicative$CoreCategory.S2_to_S3(F$1);
  var traverse = function (t, f) {
    if (t !== undefined) {
      var func = F$2.map;
      return (function (param) {
                  return Curry._2(func, param, some);
                })(Curry._1(f, Caml_option.valFromOption(t)));
    } else {
      return Curry._1(F$2.$$return, undefined);
    }
  };
  return {
          traverse: traverse
        };
}

var Traversable = {
  Make3: Make3,
  Make2: Make2,
  Make: Make
};

var forEachU = Belt_Option.forEachU;

var forEach = Belt_Option.forEach;

var getExn = Belt_Option.getExn;

var mapWithDefaultU = Belt_Option.mapWithDefaultU;

var mapWithDefault = Belt_Option.mapWithDefault;

var mapU = Belt_Option.mapU;

var flatMapU = Belt_Option.flatMapU;

var flatMap = Belt_Option.flatMap;

var getWithDefault = Belt_Option.getWithDefault;

var isSome = Belt_Option.isSome;

var isNone = Belt_Option.isNone;

var eqU = Belt_Option.eqU;

var eq = Belt_Option.eq;

var cmpU = Belt_Option.cmpU;

var cmp = Belt_Option.cmp;

var select = include.select;

var $$void = include.$$void;

var Functor_infix = include.Functor_infix;

var $less$$great = include.$less$$great;

var $less$amp$great = include.$less$amp$great;

var $less$ = include.$less$;

var $$great = include.$$great;

var $$return$1 = include.$$return;

var apply$1 = include.apply;

var liftA2 = include.liftA2;

var liftA3 = include.liftA3;

var discardFirst = include.discardFirst;

var discardSecond = include.discardSecond;

var map$1 = include.map;

var unit = include.unit;

var merge = include.merge;

var Applicative_infix = include.Applicative_infix;

var $less$star$great = include.$less$star$great;

var $star$great = include.$star$great;

var $less$star = include.$less$star;

var $star$star = include.$star$star;

var Selective_infix = include.Selective_infix;

var $less$star$question = include.$less$star$question;

var $less$pipe$pipe$great = include.$less$pipe$pipe$great;

var $less$amp$amp$great = include.$less$amp$amp$great;

var orS = include.orS;

var andS = include.andS;

var whenS = include.whenS;

var branch = include.branch;

var ifS = include.ifS;

var fromOptionS = include.fromOptionS;

var anyS = include.anyS;

var allS = include.allS;

var whileS = include.whileS;

var bind$1 = include.bind;

var Monad_infix = include.Monad_infix;

var $great$great$eq = include.$great$great$eq;

var $great$great$tilde = include.$great$great$tilde;

var $great$eq$great = include.$great$eq$great;

var join = include.join;

var forever = include.forever;

var sequenceM = include.sequenceM;

var mapM = include.mapM;

var mapM_ = include.mapM_;

exports.forEachU = forEachU;
exports.forEach = forEach;
exports.getExn = getExn;
exports.mapWithDefaultU = mapWithDefaultU;
exports.mapWithDefault = mapWithDefault;
exports.mapU = mapU;
exports.flatMapU = flatMapU;
exports.flatMap = flatMap;
exports.getWithDefault = getWithDefault;
exports.isSome = isSome;
exports.isNone = isNone;
exports.eqU = eqU;
exports.eq = eq;
exports.cmpU = cmpU;
exports.cmp = cmp;
exports.option = option;
exports.some = some;
exports.select = select;
exports.$$void = $$void;
exports.Functor_infix = Functor_infix;
exports.$less$$great = $less$$great;
exports.$less$amp$great = $less$amp$great;
exports.$less$ = $less$;
exports.$$great = $$great;
exports.$$return = $$return$1;
exports.apply = apply$1;
exports.liftA2 = liftA2;
exports.liftA3 = liftA3;
exports.discardFirst = discardFirst;
exports.discardSecond = discardSecond;
exports.map = map$1;
exports.unit = unit;
exports.merge = merge;
exports.Applicative_infix = Applicative_infix;
exports.$less$star$great = $less$star$great;
exports.$star$great = $star$great;
exports.$less$star = $less$star;
exports.$star$star = $star$star;
exports.Selective_infix = Selective_infix;
exports.$less$star$question = $less$star$question;
exports.$less$pipe$pipe$great = $less$pipe$pipe$great;
exports.$less$amp$amp$great = $less$amp$amp$great;
exports.orS = orS;
exports.andS = andS;
exports.whenS = whenS;
exports.branch = branch;
exports.ifS = ifS;
exports.fromOptionS = fromOptionS;
exports.anyS = anyS;
exports.allS = allS;
exports.whileS = whileS;
exports.bind = bind$1;
exports.Monad_infix = Monad_infix;
exports.$great$great$eq = $great$great$eq;
exports.$great$great$tilde = $great$great$tilde;
exports.$great$eq$great = $great$eq$great;
exports.join = join;
exports.forever = forever;
exports.sequenceM = sequenceM;
exports.mapM = mapM;
exports.mapM_ = mapM_;
exports.map2 = map2;
exports.Traversable = Traversable;
/* include Not a pure module */
