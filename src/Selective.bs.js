// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var EitherBase$CoreCategory = require("./EitherBase.bs.js");
var Applicative$CoreCategory = require("./Applicative.bs.js");

function S1_to_S2(X) {
  return {
          map: X.map,
          replace: X.replace,
          $$void: X.$$void,
          FunctorInfix: X.FunctorInfix,
          $less$$great: X.$less$$great,
          $less$amp$great: X.$less$amp$great,
          $less$: X.$less$,
          $$great: X.$$great,
          apply: X.apply,
          applyFirst: X.applyFirst,
          applySecond: X.applySecond,
          liftA2: X.liftA2,
          ApplyInfix: X.ApplyInfix,
          $less$star$great: X.$less$star$great,
          $star$great: X.$star$great,
          $less$star: X.$less$star,
          $star$star: X.$star$star,
          liftA3: X.liftA3,
          liftA4: X.liftA4,
          liftA5: X.liftA5,
          merge: X.merge,
          pure: X.pure,
          when_: X.when_,
          unless: X.unless,
          select: X.select,
          SelectiveInfix: X.SelectiveInfix,
          $less$star$question: X.$less$star$question,
          $less$pipe$pipe$great: X.$less$pipe$pipe$great,
          $less$amp$amp$great: X.$less$amp$amp$great,
          orS: X.orS,
          andS: X.andS,
          whenS: X.whenS,
          branch: X.branch,
          ifS: X.ifS,
          fromOptionS: X.fromOptionS,
          anyS: X.anyS,
          allS: X.allS,
          whileS: X.whileS
        };
}

function S2_to_S1(X) {
  return {
          map: X.map,
          replace: X.replace,
          $$void: X.$$void,
          FunctorInfix: X.FunctorInfix,
          $less$$great: X.$less$$great,
          $less$amp$great: X.$less$amp$great,
          $less$: X.$less$,
          $$great: X.$$great,
          apply: X.apply,
          liftA2: X.liftA2,
          applyFirst: X.applyFirst,
          applySecond: X.applySecond,
          ApplyInfix: X.ApplyInfix,
          $less$star$great: X.$less$star$great,
          $star$great: X.$star$great,
          $less$star: X.$less$star,
          $star$star: X.$star$star,
          liftA3: X.liftA3,
          liftA4: X.liftA4,
          liftA5: X.liftA5,
          merge: X.merge,
          pure: X.pure,
          when_: X.when_,
          unless: X.unless,
          select: X.select,
          SelectiveInfix: X.SelectiveInfix,
          $less$star$question: X.$less$star$question,
          $less$pipe$pipe$great: X.$less$pipe$pipe$great,
          $less$amp$amp$great: X.$less$amp$amp$great,
          orS: X.orS,
          andS: X.andS,
          whenS: X.whenS,
          branch: X.branch,
          ifS: X.ifS,
          fromOptionS: X.fromOptionS,
          anyS: X.anyS,
          allS: X.allS,
          whileS: X.whileS
        };
}

function S2_to_S3(X) {
  return X;
}

function S3_to_S2(X) {
  return X;
}

function MakeCustom3(X) {
  var include = Applicative$CoreCategory.MakeCustom3(X);
  var map = include.map;
  var $less$$great = include.$less$$great;
  var pure = include.pure;
  var select = X.select;
  var branch = function (t, first, second) {
    var arg = function (x) {
      return x;
    };
    var x = Curry._2(map, t, (function (param) {
            return Curry._3(EitherBase$CoreCategory.bimap, param, arg, EitherBase$CoreCategory.first);
          }));
    var f = Curry._2(map, first, (function (g, x) {
            return EitherBase$CoreCategory.second(Curry._1(g, x));
          }));
    return Curry._2(select, Curry._2(select, x, f), second);
  };
  var ifS = function (x, t, f) {
    return branch(Curry._2(map, x, (function (b) {
                      if (b) {
                        return /* First */Block.__(0, [/* () */0]);
                      } else {
                        return /* Second */Block.__(1, [/* () */0]);
                      }
                    })), Curry._2(map, t, (function (x, param) {
                      return x;
                    })), Curry._2(map, f, (function (x, param) {
                      return x;
                    })));
  };
  var whenS = function (x, act) {
    return ifS(x, act, Curry._1(pure, /* () */0));
  };
  var orS = function (x, y) {
    return ifS(x, Curry._1(pure, true), y);
  };
  var andS = function (x, y) {
    return ifS(x, y, Curry._1(pure, false));
  };
  var fromOptionS = function (x, mx) {
    var y = Curry._2(map, mx, (function (param) {
            if (param !== undefined) {
              return EitherBase$CoreCategory.second(Caml_option.valFromOption(param));
            } else {
              return EitherBase$CoreCategory.first(/* () */0);
            }
          }));
    return Curry._2(select, y, Curry._2($less$$great, (function (x, param) {
                      return x;
                    }), x));
  };
  var $less$star$question = Curry.__2(select);
  var $less$pipe$pipe$great = orS;
  var $less$amp$amp$great = andS;
  var SelectiveInfix = {
    $less$star$question: $less$star$question,
    $less$pipe$pipe$great: $less$pipe$pipe$great,
    $less$amp$amp$great: $less$amp$amp$great
  };
  var anyS = function (xs, pred) {
    return Belt_List.reduceReverse(xs, Curry._1(pure, false), (function (accu, x) {
                  return orS(accu, Curry._1(pred, x));
                }));
  };
  var allS = function (xs, pred) {
    return Belt_List.reduceReverse(xs, Curry._1(pure, true), (function (accu, x) {
                  return andS(accu, Curry._1(pred, x));
                }));
  };
  var whileS = function (x) {
    return whenS(x, whileS(x));
  };
  return {
          map: map,
          replace: include.replace,
          $$void: include.$$void,
          FunctorInfix: include.FunctorInfix,
          $less$$great: $less$$great,
          $less$amp$great: include.$less$amp$great,
          $less$: include.$less$,
          $$great: include.$$great,
          apply: include.apply,
          applyFirst: include.applyFirst,
          applySecond: include.applySecond,
          liftA2: include.liftA2,
          ApplyInfix: include.ApplyInfix,
          $less$star$great: include.$less$star$great,
          $star$great: include.$star$great,
          $less$star: include.$less$star,
          $star$star: include.$star$star,
          liftA3: include.liftA3,
          liftA4: include.liftA4,
          liftA5: include.liftA5,
          merge: include.merge,
          pure: pure,
          when_: include.when_,
          unless: include.unless,
          select: select,
          SelectiveInfix: SelectiveInfix,
          $less$star$question: $less$star$question,
          $less$pipe$pipe$great: $less$pipe$pipe$great,
          $less$amp$amp$great: $less$amp$amp$great,
          orS: orS,
          andS: andS,
          whenS: whenS,
          branch: branch,
          ifS: ifS,
          fromOptionS: fromOptionS,
          anyS: anyS,
          allS: allS,
          whileS: whileS
        };
}

function MakeCustom2(X) {
  var select = X.select;
  var X_pure = X.pure;
  var X_apply = X.apply;
  var X_map = X.map;
  var X_replace = X.replace;
  var X_liftA2 = X.liftA2;
  var X_applyFirst = X.applyFirst;
  var X_applySecond = X.applySecond;
  var X$1 = {
    pure: X_pure,
    apply: X_apply,
    map: X_map,
    replace: X_replace,
    liftA2: X_liftA2,
    applyFirst: X_applyFirst,
    applySecond: X_applySecond,
    select: select
  };
  var include = Applicative$CoreCategory.MakeCustom3(X$1);
  var map = include.map;
  var $less$$great = include.$less$$great;
  var pure = include.pure;
  var branch = function (t, first, second) {
    var arg = function (x) {
      return x;
    };
    var x = Curry._2(map, t, (function (param) {
            return Curry._3(EitherBase$CoreCategory.bimap, param, arg, EitherBase$CoreCategory.first);
          }));
    var f = Curry._2(map, first, (function (g, x) {
            return EitherBase$CoreCategory.second(Curry._1(g, x));
          }));
    return Curry._2(select, Curry._2(select, x, f), second);
  };
  var ifS = function (x, t, f) {
    return branch(Curry._2(map, x, (function (b) {
                      if (b) {
                        return /* First */Block.__(0, [/* () */0]);
                      } else {
                        return /* Second */Block.__(1, [/* () */0]);
                      }
                    })), Curry._2(map, t, (function (x, param) {
                      return x;
                    })), Curry._2(map, f, (function (x, param) {
                      return x;
                    })));
  };
  var whenS = function (x, act) {
    return ifS(x, act, Curry._1(pure, /* () */0));
  };
  var orS = function (x, y) {
    return ifS(x, Curry._1(pure, true), y);
  };
  var andS = function (x, y) {
    return ifS(x, y, Curry._1(pure, false));
  };
  var fromOptionS = function (x, mx) {
    var y = Curry._2(map, mx, (function (param) {
            if (param !== undefined) {
              return EitherBase$CoreCategory.second(Caml_option.valFromOption(param));
            } else {
              return EitherBase$CoreCategory.first(/* () */0);
            }
          }));
    return Curry._2(select, y, Curry._2($less$$great, (function (x, param) {
                      return x;
                    }), x));
  };
  var $less$star$question = Curry.__2(select);
  var $less$pipe$pipe$great = orS;
  var $less$amp$amp$great = andS;
  var SelectiveInfix = {
    $less$star$question: $less$star$question,
    $less$pipe$pipe$great: $less$pipe$pipe$great,
    $less$amp$amp$great: $less$amp$amp$great
  };
  var anyS = function (xs, pred) {
    return Belt_List.reduceReverse(xs, Curry._1(pure, false), (function (accu, x) {
                  return orS(accu, Curry._1(pred, x));
                }));
  };
  var allS = function (xs, pred) {
    return Belt_List.reduceReverse(xs, Curry._1(pure, true), (function (accu, x) {
                  return andS(accu, Curry._1(pred, x));
                }));
  };
  var whileS = function (x) {
    return whenS(x, whileS(x));
  };
  return {
          map: map,
          replace: include.replace,
          $$void: include.$$void,
          FunctorInfix: include.FunctorInfix,
          $less$$great: $less$$great,
          $less$amp$great: include.$less$amp$great,
          $less$: include.$less$,
          $$great: include.$$great,
          apply: include.apply,
          applyFirst: include.applyFirst,
          applySecond: include.applySecond,
          liftA2: include.liftA2,
          ApplyInfix: include.ApplyInfix,
          $less$star$great: include.$less$star$great,
          $star$great: include.$star$great,
          $less$star: include.$less$star,
          $star$star: include.$star$star,
          liftA3: include.liftA3,
          liftA4: include.liftA4,
          liftA5: include.liftA5,
          merge: include.merge,
          pure: pure,
          when_: include.when_,
          unless: include.unless,
          select: select,
          SelectiveInfix: SelectiveInfix,
          $less$star$question: $less$star$question,
          $less$pipe$pipe$great: $less$pipe$pipe$great,
          $less$amp$amp$great: $less$amp$amp$great,
          orS: orS,
          andS: andS,
          whenS: whenS,
          branch: branch,
          ifS: ifS,
          fromOptionS: fromOptionS,
          anyS: anyS,
          allS: allS,
          whileS: whileS
        };
}

function MakeCustom1(X) {
  var select = X.select;
  var X_pure = X.pure;
  var X_apply = X.apply;
  var X_map = X.map;
  var X_replace = X.replace;
  var X_liftA2 = X.liftA2;
  var X_applyFirst = X.applyFirst;
  var X_applySecond = X.applySecond;
  var X$1 = {
    pure: X_pure,
    apply: X_apply,
    map: X_map,
    replace: X_replace,
    liftA2: X_liftA2,
    applyFirst: X_applyFirst,
    applySecond: X_applySecond,
    select: select
  };
  var include = Applicative$CoreCategory.MakeCustom3(X$1);
  var map = include.map;
  var $less$$great = include.$less$$great;
  var pure = include.pure;
  var branch = function (t, first, second) {
    var arg = function (x) {
      return x;
    };
    var x = Curry._2(map, t, (function (param) {
            return Curry._3(EitherBase$CoreCategory.bimap, param, arg, EitherBase$CoreCategory.first);
          }));
    var f = Curry._2(map, first, (function (g, x) {
            return EitherBase$CoreCategory.second(Curry._1(g, x));
          }));
    return Curry._2(select, Curry._2(select, x, f), second);
  };
  var ifS = function (x, t, f) {
    return branch(Curry._2(map, x, (function (b) {
                      if (b) {
                        return /* First */Block.__(0, [/* () */0]);
                      } else {
                        return /* Second */Block.__(1, [/* () */0]);
                      }
                    })), Curry._2(map, t, (function (x, param) {
                      return x;
                    })), Curry._2(map, f, (function (x, param) {
                      return x;
                    })));
  };
  var whenS = function (x, act) {
    return ifS(x, act, Curry._1(pure, /* () */0));
  };
  var orS = function (x, y) {
    return ifS(x, Curry._1(pure, true), y);
  };
  var andS = function (x, y) {
    return ifS(x, y, Curry._1(pure, false));
  };
  var fromOptionS = function (x, mx) {
    var y = Curry._2(map, mx, (function (param) {
            if (param !== undefined) {
              return EitherBase$CoreCategory.second(Caml_option.valFromOption(param));
            } else {
              return EitherBase$CoreCategory.first(/* () */0);
            }
          }));
    return Curry._2(select, y, Curry._2($less$$great, (function (x, param) {
                      return x;
                    }), x));
  };
  var $less$star$question = Curry.__2(select);
  var $less$pipe$pipe$great = orS;
  var $less$amp$amp$great = andS;
  var SelectiveInfix = {
    $less$star$question: $less$star$question,
    $less$pipe$pipe$great: $less$pipe$pipe$great,
    $less$amp$amp$great: $less$amp$amp$great
  };
  var anyS = function (xs, pred) {
    return Belt_List.reduceReverse(xs, Curry._1(pure, false), (function (accu, x) {
                  return orS(accu, Curry._1(pred, x));
                }));
  };
  var allS = function (xs, pred) {
    return Belt_List.reduceReverse(xs, Curry._1(pure, true), (function (accu, x) {
                  return andS(accu, Curry._1(pred, x));
                }));
  };
  var whileS = function (x) {
    return whenS(x, whileS(x));
  };
  return {
          map: map,
          replace: include.replace,
          $$void: include.$$void,
          FunctorInfix: include.FunctorInfix,
          $less$$great: $less$$great,
          $less$amp$great: include.$less$amp$great,
          $less$: include.$less$,
          $$great: include.$$great,
          apply: include.apply,
          liftA2: include.liftA2,
          applyFirst: include.applyFirst,
          applySecond: include.applySecond,
          ApplyInfix: include.ApplyInfix,
          $less$star$great: include.$less$star$great,
          $star$great: include.$star$great,
          $less$star: include.$less$star,
          $star$star: include.$star$star,
          liftA3: include.liftA3,
          liftA4: include.liftA4,
          liftA5: include.liftA5,
          merge: include.merge,
          pure: pure,
          when_: include.when_,
          unless: include.unless,
          select: select,
          SelectiveInfix: SelectiveInfix,
          $less$star$question: $less$star$question,
          $less$pipe$pipe$great: $less$pipe$pipe$great,
          $less$amp$amp$great: $less$amp$amp$great,
          orS: orS,
          andS: andS,
          whenS: whenS,
          branch: branch,
          ifS: ifS,
          fromOptionS: fromOptionS,
          anyS: anyS,
          allS: allS,
          whileS: whileS
        };
}

function Make3(X) {
  var select = X.select;
  var X_pure = X.pure;
  var X_apply = X.apply;
  var X$1 = {
    pure: X_pure,
    apply: X_apply,
    map: /* Derived */-684824643,
    replace: /* Derived */-684824643,
    liftA2: /* Derived */-684824643,
    applyFirst: /* Derived */-684824643,
    applySecond: /* Derived */-684824643,
    select: select
  };
  var include = Applicative$CoreCategory.MakeCustom3(X$1);
  var map = include.map;
  var $less$$great = include.$less$$great;
  var pure = include.pure;
  var branch = function (t, first, second) {
    var arg = function (x) {
      return x;
    };
    var x = Curry._2(map, t, (function (param) {
            return Curry._3(EitherBase$CoreCategory.bimap, param, arg, EitherBase$CoreCategory.first);
          }));
    var f = Curry._2(map, first, (function (g, x) {
            return EitherBase$CoreCategory.second(Curry._1(g, x));
          }));
    return Curry._2(select, Curry._2(select, x, f), second);
  };
  var ifS = function (x, t, f) {
    return branch(Curry._2(map, x, (function (b) {
                      if (b) {
                        return /* First */Block.__(0, [/* () */0]);
                      } else {
                        return /* Second */Block.__(1, [/* () */0]);
                      }
                    })), Curry._2(map, t, (function (x, param) {
                      return x;
                    })), Curry._2(map, f, (function (x, param) {
                      return x;
                    })));
  };
  var whenS = function (x, act) {
    return ifS(x, act, Curry._1(pure, /* () */0));
  };
  var orS = function (x, y) {
    return ifS(x, Curry._1(pure, true), y);
  };
  var andS = function (x, y) {
    return ifS(x, y, Curry._1(pure, false));
  };
  var fromOptionS = function (x, mx) {
    var y = Curry._2(map, mx, (function (param) {
            if (param !== undefined) {
              return EitherBase$CoreCategory.second(Caml_option.valFromOption(param));
            } else {
              return EitherBase$CoreCategory.first(/* () */0);
            }
          }));
    return Curry._2(select, y, Curry._2($less$$great, (function (x, param) {
                      return x;
                    }), x));
  };
  var $less$star$question = Curry.__2(select);
  var $less$pipe$pipe$great = orS;
  var $less$amp$amp$great = andS;
  var SelectiveInfix = {
    $less$star$question: $less$star$question,
    $less$pipe$pipe$great: $less$pipe$pipe$great,
    $less$amp$amp$great: $less$amp$amp$great
  };
  var anyS = function (xs, pred) {
    return Belt_List.reduceReverse(xs, Curry._1(pure, false), (function (accu, x) {
                  return orS(accu, Curry._1(pred, x));
                }));
  };
  var allS = function (xs, pred) {
    return Belt_List.reduceReverse(xs, Curry._1(pure, true), (function (accu, x) {
                  return andS(accu, Curry._1(pred, x));
                }));
  };
  var whileS = function (x) {
    return whenS(x, whileS(x));
  };
  return {
          map: map,
          replace: include.replace,
          $$void: include.$$void,
          FunctorInfix: include.FunctorInfix,
          $less$$great: $less$$great,
          $less$amp$great: include.$less$amp$great,
          $less$: include.$less$,
          $$great: include.$$great,
          apply: include.apply,
          applyFirst: include.applyFirst,
          applySecond: include.applySecond,
          liftA2: include.liftA2,
          ApplyInfix: include.ApplyInfix,
          $less$star$great: include.$less$star$great,
          $star$great: include.$star$great,
          $less$star: include.$less$star,
          $star$star: include.$star$star,
          liftA3: include.liftA3,
          liftA4: include.liftA4,
          liftA5: include.liftA5,
          merge: include.merge,
          pure: pure,
          when_: include.when_,
          unless: include.unless,
          select: select,
          SelectiveInfix: SelectiveInfix,
          $less$star$question: $less$star$question,
          $less$pipe$pipe$great: $less$pipe$pipe$great,
          $less$amp$amp$great: $less$amp$amp$great,
          orS: orS,
          andS: andS,
          whenS: whenS,
          branch: branch,
          ifS: ifS,
          fromOptionS: fromOptionS,
          anyS: anyS,
          allS: allS,
          whileS: whileS
        };
}

function Make2(X) {
  var select = X.select;
  var X_pure = X.pure;
  var X_apply = X.apply;
  var X$1 = {
    pure: X_pure,
    apply: X_apply,
    map: /* Derived */-684824643,
    replace: /* Derived */-684824643,
    liftA2: /* Derived */-684824643,
    applyFirst: /* Derived */-684824643,
    applySecond: /* Derived */-684824643,
    select: select
  };
  var include = Applicative$CoreCategory.MakeCustom3(X$1);
  var map = include.map;
  var $less$$great = include.$less$$great;
  var pure = include.pure;
  var branch = function (t, first, second) {
    var arg = function (x) {
      return x;
    };
    var x = Curry._2(map, t, (function (param) {
            return Curry._3(EitherBase$CoreCategory.bimap, param, arg, EitherBase$CoreCategory.first);
          }));
    var f = Curry._2(map, first, (function (g, x) {
            return EitherBase$CoreCategory.second(Curry._1(g, x));
          }));
    return Curry._2(select, Curry._2(select, x, f), second);
  };
  var ifS = function (x, t, f) {
    return branch(Curry._2(map, x, (function (b) {
                      if (b) {
                        return /* First */Block.__(0, [/* () */0]);
                      } else {
                        return /* Second */Block.__(1, [/* () */0]);
                      }
                    })), Curry._2(map, t, (function (x, param) {
                      return x;
                    })), Curry._2(map, f, (function (x, param) {
                      return x;
                    })));
  };
  var whenS = function (x, act) {
    return ifS(x, act, Curry._1(pure, /* () */0));
  };
  var orS = function (x, y) {
    return ifS(x, Curry._1(pure, true), y);
  };
  var andS = function (x, y) {
    return ifS(x, y, Curry._1(pure, false));
  };
  var fromOptionS = function (x, mx) {
    var y = Curry._2(map, mx, (function (param) {
            if (param !== undefined) {
              return EitherBase$CoreCategory.second(Caml_option.valFromOption(param));
            } else {
              return EitherBase$CoreCategory.first(/* () */0);
            }
          }));
    return Curry._2(select, y, Curry._2($less$$great, (function (x, param) {
                      return x;
                    }), x));
  };
  var $less$star$question = Curry.__2(select);
  var $less$pipe$pipe$great = orS;
  var $less$amp$amp$great = andS;
  var SelectiveInfix = {
    $less$star$question: $less$star$question,
    $less$pipe$pipe$great: $less$pipe$pipe$great,
    $less$amp$amp$great: $less$amp$amp$great
  };
  var anyS = function (xs, pred) {
    return Belt_List.reduceReverse(xs, Curry._1(pure, false), (function (accu, x) {
                  return orS(accu, Curry._1(pred, x));
                }));
  };
  var allS = function (xs, pred) {
    return Belt_List.reduceReverse(xs, Curry._1(pure, true), (function (accu, x) {
                  return andS(accu, Curry._1(pred, x));
                }));
  };
  var whileS = function (x) {
    return whenS(x, whileS(x));
  };
  return {
          map: map,
          replace: include.replace,
          $$void: include.$$void,
          FunctorInfix: include.FunctorInfix,
          $less$$great: $less$$great,
          $less$amp$great: include.$less$amp$great,
          $less$: include.$less$,
          $$great: include.$$great,
          apply: include.apply,
          applyFirst: include.applyFirst,
          applySecond: include.applySecond,
          liftA2: include.liftA2,
          ApplyInfix: include.ApplyInfix,
          $less$star$great: include.$less$star$great,
          $star$great: include.$star$great,
          $less$star: include.$less$star,
          $star$star: include.$star$star,
          liftA3: include.liftA3,
          liftA4: include.liftA4,
          liftA5: include.liftA5,
          merge: include.merge,
          pure: pure,
          when_: include.when_,
          unless: include.unless,
          select: select,
          SelectiveInfix: SelectiveInfix,
          $less$star$question: $less$star$question,
          $less$pipe$pipe$great: $less$pipe$pipe$great,
          $less$amp$amp$great: $less$amp$amp$great,
          orS: orS,
          andS: andS,
          whenS: whenS,
          branch: branch,
          ifS: ifS,
          fromOptionS: fromOptionS,
          anyS: anyS,
          allS: allS,
          whileS: whileS
        };
}

function Make1(X) {
  var select = X.select;
  var X_pure = X.pure;
  var X_apply = X.apply;
  var X$1 = {
    pure: X_pure,
    apply: X_apply,
    map: /* Derived */-684824643,
    replace: /* Derived */-684824643,
    liftA2: /* Derived */-684824643,
    applyFirst: /* Derived */-684824643,
    applySecond: /* Derived */-684824643,
    select: select
  };
  var include = Applicative$CoreCategory.MakeCustom3(X$1);
  var map = include.map;
  var $less$$great = include.$less$$great;
  var pure = include.pure;
  var branch = function (t, first, second) {
    var arg = function (x) {
      return x;
    };
    var x = Curry._2(map, t, (function (param) {
            return Curry._3(EitherBase$CoreCategory.bimap, param, arg, EitherBase$CoreCategory.first);
          }));
    var f = Curry._2(map, first, (function (g, x) {
            return EitherBase$CoreCategory.second(Curry._1(g, x));
          }));
    return Curry._2(select, Curry._2(select, x, f), second);
  };
  var ifS = function (x, t, f) {
    return branch(Curry._2(map, x, (function (b) {
                      if (b) {
                        return /* First */Block.__(0, [/* () */0]);
                      } else {
                        return /* Second */Block.__(1, [/* () */0]);
                      }
                    })), Curry._2(map, t, (function (x, param) {
                      return x;
                    })), Curry._2(map, f, (function (x, param) {
                      return x;
                    })));
  };
  var whenS = function (x, act) {
    return ifS(x, act, Curry._1(pure, /* () */0));
  };
  var orS = function (x, y) {
    return ifS(x, Curry._1(pure, true), y);
  };
  var andS = function (x, y) {
    return ifS(x, y, Curry._1(pure, false));
  };
  var fromOptionS = function (x, mx) {
    var y = Curry._2(map, mx, (function (param) {
            if (param !== undefined) {
              return EitherBase$CoreCategory.second(Caml_option.valFromOption(param));
            } else {
              return EitherBase$CoreCategory.first(/* () */0);
            }
          }));
    return Curry._2(select, y, Curry._2($less$$great, (function (x, param) {
                      return x;
                    }), x));
  };
  var $less$star$question = Curry.__2(select);
  var $less$pipe$pipe$great = orS;
  var $less$amp$amp$great = andS;
  var SelectiveInfix = {
    $less$star$question: $less$star$question,
    $less$pipe$pipe$great: $less$pipe$pipe$great,
    $less$amp$amp$great: $less$amp$amp$great
  };
  var anyS = function (xs, pred) {
    return Belt_List.reduceReverse(xs, Curry._1(pure, false), (function (accu, x) {
                  return orS(accu, Curry._1(pred, x));
                }));
  };
  var allS = function (xs, pred) {
    return Belt_List.reduceReverse(xs, Curry._1(pure, true), (function (accu, x) {
                  return andS(accu, Curry._1(pred, x));
                }));
  };
  var whileS = function (x) {
    return whenS(x, whileS(x));
  };
  return {
          map: map,
          replace: include.replace,
          $$void: include.$$void,
          FunctorInfix: include.FunctorInfix,
          $less$$great: $less$$great,
          $less$amp$great: include.$less$amp$great,
          $less$: include.$less$,
          $$great: include.$$great,
          apply: include.apply,
          liftA2: include.liftA2,
          applyFirst: include.applyFirst,
          applySecond: include.applySecond,
          ApplyInfix: include.ApplyInfix,
          $less$star$great: include.$less$star$great,
          $star$great: include.$star$great,
          $less$star: include.$less$star,
          $star$star: include.$star$star,
          liftA3: include.liftA3,
          liftA4: include.liftA4,
          liftA5: include.liftA5,
          merge: include.merge,
          pure: pure,
          when_: include.when_,
          unless: include.unless,
          select: select,
          SelectiveInfix: SelectiveInfix,
          $less$star$question: $less$star$question,
          $less$pipe$pipe$great: $less$pipe$pipe$great,
          $less$amp$amp$great: $less$amp$amp$great,
          orS: orS,
          andS: andS,
          whenS: whenS,
          branch: branch,
          ifS: ifS,
          fromOptionS: fromOptionS,
          anyS: anyS,
          allS: allS,
          whileS: whileS
        };
}

exports.S1_to_S2 = S1_to_S2;
exports.S2_to_S1 = S2_to_S1;
exports.S2_to_S3 = S2_to_S3;
exports.S3_to_S2 = S3_to_S2;
exports.MakeCustom1 = MakeCustom1;
exports.MakeCustom2 = MakeCustom2;
exports.MakeCustom3 = MakeCustom3;
exports.Make1 = Make1;
exports.Make2 = Make2;
exports.Make3 = Make3;
/* EitherBase-CoreCategory Not a pure module */
