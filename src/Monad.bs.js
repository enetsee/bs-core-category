// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Selective$CoreCategory = require("./Selective.bs.js");

function S1_to_S2(X) {
  return {
          map: X.map,
          replace: X.replace,
          $$void: X.$$void,
          FunctorInfix: X.FunctorInfix,
          $less$$great: X.$less$$great,
          $less$amp$great: X.$less$amp$great,
          $less$: X.$less$,
          $$great: X.$$great,
          apply: X.apply,
          applyFirst: X.applyFirst,
          applySecond: X.applySecond,
          liftA2: X.liftA2,
          ApplyInfix: X.ApplyInfix,
          $less$star$great: X.$less$star$great,
          $star$great: X.$star$great,
          $less$star: X.$less$star,
          $star$star: X.$star$star,
          liftA3: X.liftA3,
          liftA4: X.liftA4,
          liftA5: X.liftA5,
          merge: X.merge,
          pure: X.pure,
          when_: X.when_,
          unless: X.unless,
          select: X.select,
          SelectiveInfix: X.SelectiveInfix,
          $less$star$question: X.$less$star$question,
          $less$pipe$pipe$great: X.$less$pipe$pipe$great,
          $less$amp$amp$great: X.$less$amp$amp$great,
          orS: X.orS,
          andS: X.andS,
          whenS: X.whenS,
          branch: X.branch,
          ifS: X.ifS,
          fromOptionS: X.fromOptionS,
          anyS: X.anyS,
          allS: X.allS,
          whileS: X.whileS,
          bind: X.bind,
          MonadInfix: X.MonadInfix,
          $great$great$eq: X.$great$great$eq,
          $great$great$tilde: X.$great$great$tilde,
          $great$eq$great: X.$great$eq$great,
          join: X.join,
          forever: X.forever,
          sequenceM: X.sequenceM,
          mapM: X.mapM,
          mapM_: X.mapM_
        };
}

function S2_to_S1(X) {
  return {
          map: X.map,
          replace: X.replace,
          $$void: X.$$void,
          FunctorInfix: X.FunctorInfix,
          $less$$great: X.$less$$great,
          $less$amp$great: X.$less$amp$great,
          $less$: X.$less$,
          $$great: X.$$great,
          apply: X.apply,
          liftA2: X.liftA2,
          applyFirst: X.applyFirst,
          applySecond: X.applySecond,
          ApplyInfix: X.ApplyInfix,
          $less$star$great: X.$less$star$great,
          $star$great: X.$star$great,
          $less$star: X.$less$star,
          $star$star: X.$star$star,
          liftA3: X.liftA3,
          liftA4: X.liftA4,
          liftA5: X.liftA5,
          merge: X.merge,
          pure: X.pure,
          when_: X.when_,
          unless: X.unless,
          select: X.select,
          SelectiveInfix: X.SelectiveInfix,
          $less$star$question: X.$less$star$question,
          $less$pipe$pipe$great: X.$less$pipe$pipe$great,
          $less$amp$amp$great: X.$less$amp$amp$great,
          orS: X.orS,
          andS: X.andS,
          whenS: X.whenS,
          branch: X.branch,
          ifS: X.ifS,
          fromOptionS: X.fromOptionS,
          anyS: X.anyS,
          allS: X.allS,
          whileS: X.whileS,
          bind: X.bind,
          MonadInfix: X.MonadInfix,
          $great$great$eq: X.$great$great$eq,
          $great$great$tilde: X.$great$great$tilde,
          $great$eq$great: X.$great$eq$great,
          join: X.join,
          forever: X.forever,
          sequenceM: X.sequenceM,
          mapM: X.mapM,
          mapM_: X.mapM_
        };
}

function S2_to_S3(X) {
  return X;
}

function S3_to_S2(X) {
  return X;
}

function MakeCustom3(X) {
  var bind = X.bind;
  var pure = X.pure;
  var match = X.apply;
  var apply;
  var exit = 0;
  if (typeof match === "number" || match[0] !== -198771759) {
    exit = 1;
  } else {
    apply = match[1];
  }
  if (exit === 1) {
    apply = (function (t, f) {
        return Curry._2(bind, f, (function (g) {
                      return Curry._2(bind, t, (function (x) {
                                    return Curry._1(pure, Curry._1(g, x));
                                  }));
                    }));
      });
  }
  var match$1 = X.select;
  var select;
  var exit$1 = 0;
  if (typeof match$1 === "number" || match$1[0] !== -198771759) {
    exit$1 = 1;
  } else {
    select = match$1[1];
  }
  if (exit$1 === 1) {
    select = (function (x, f) {
        return Curry._2(bind, x, (function (param) {
                      if (param.tag) {
                        return Curry._1(pure, param[0]);
                      } else {
                        var a = param[0];
                        return Curry._2(bind, f, (function (g) {
                                      return Curry._1(pure, Curry._1(g, a));
                                    }));
                      }
                    }));
      });
  }
  var include = Selective$CoreCategory.MakeCustom3({
        pure: pure,
        apply: apply,
        map: X.map,
        replace: X.replace,
        liftA2: X.liftA2,
        applyFirst: X.applyFirst,
        applySecond: X.applySecond,
        select: select
      });
  var pure$1 = include.pure;
  var $great$great$eq = Curry.__2(bind);
  var $great$great$tilde = function (m, n) {
    return Curry._2(bind, m, (function (param) {
                  return n;
                }));
  };
  var $great$eq$great = function (f, g, a) {
    return Curry._2(bind, Curry._1(f, a), g);
  };
  var MonadInfix = {
    $great$great$eq: $great$great$eq,
    $great$great$tilde: $great$great$tilde,
    $great$eq$great: $great$eq$great
  };
  var join = function (tt) {
    return Curry._2(bind, tt, (function (x) {
                  return x;
                }));
  };
  var sequenceM = function (ts) {
    var op = function (n, m) {
      return Curry._2(bind, m, (function (x) {
                    return Curry._2(bind, n, (function (xs) {
                                  return Curry._1(pure$1, /* :: */[
                                              x,
                                              xs
                                            ]);
                                }));
                  }));
    };
    return Belt_List.reduceReverse(ts, Curry._1(pure$1, /* [] */0), op);
  };
  var Undefined = Caml_exceptions.create("Monad-CoreCategory.MakeCustom3(X).Undefined");
  var forever = function (f) {
    var z = function (param) {
      throw Undefined;
    };
    var kcell = {
      contents: (function (x) {
          return x;
        })
    };
    var aux = function (param) {
      return Curry._1(kcell.contents, Curry._2(bind, Curry._1(f, (kcell.contents = (function (x) {
                              return x;
                            }), /* () */0)), chained));
    };
    var chained = function (param) {
      kcell.contents = aux;
      return z;
    };
    return aux(z);
  };
  var mapM = function (xs, f) {
    return sequenceM(Belt_List.map(xs, f));
  };
  var mapM_ = function (xs, f) {
    return Belt_List.reduceReverse(xs, Curry._1(pure$1, /* () */0), (function (accu, x) {
                  return Curry._2(bind, Curry._1(f, x), (function (param) {
                                return accu;
                              }));
                }));
  };
  return {
          map: include.map,
          replace: include.replace,
          $$void: include.$$void,
          FunctorInfix: include.FunctorInfix,
          $less$$great: include.$less$$great,
          $less$amp$great: include.$less$amp$great,
          $less$: include.$less$,
          $$great: include.$$great,
          apply: include.apply,
          applyFirst: include.applyFirst,
          applySecond: include.applySecond,
          liftA2: include.liftA2,
          ApplyInfix: include.ApplyInfix,
          $less$star$great: include.$less$star$great,
          $star$great: include.$star$great,
          $less$star: include.$less$star,
          $star$star: include.$star$star,
          liftA3: include.liftA3,
          liftA4: include.liftA4,
          liftA5: include.liftA5,
          merge: include.merge,
          pure: pure$1,
          when_: include.when_,
          unless: include.unless,
          select: include.select,
          SelectiveInfix: include.SelectiveInfix,
          $less$star$question: include.$less$star$question,
          $less$pipe$pipe$great: include.$less$pipe$pipe$great,
          $less$amp$amp$great: include.$less$amp$amp$great,
          orS: include.orS,
          andS: include.andS,
          whenS: include.whenS,
          branch: include.branch,
          ifS: include.ifS,
          fromOptionS: include.fromOptionS,
          anyS: include.anyS,
          allS: include.allS,
          whileS: include.whileS,
          bind: bind,
          MonadInfix: MonadInfix,
          $great$great$eq: $great$great$eq,
          $great$great$tilde: $great$great$tilde,
          $great$eq$great: $great$eq$great,
          join: join,
          forever: forever,
          sequenceM: sequenceM,
          mapM: mapM,
          mapM_: mapM_
        };
}

function MakeCustom2(X) {
  var pure = X.pure;
  var bind = X.bind;
  var apply = X.apply;
  var select = X.select;
  var apply$1;
  var exit = 0;
  if (typeof apply === "number" || apply[0] !== -198771759) {
    exit = 1;
  } else {
    apply$1 = apply[1];
  }
  if (exit === 1) {
    apply$1 = (function (t, f) {
        return Curry._2(bind, f, (function (g) {
                      return Curry._2(bind, t, (function (x) {
                                    return Curry._1(pure, Curry._1(g, x));
                                  }));
                    }));
      });
  }
  var select$1;
  var exit$1 = 0;
  if (typeof select === "number" || select[0] !== -198771759) {
    exit$1 = 1;
  } else {
    select$1 = select[1];
  }
  if (exit$1 === 1) {
    select$1 = (function (x, f) {
        return Curry._2(bind, x, (function (param) {
                      if (param.tag) {
                        return Curry._1(pure, param[0]);
                      } else {
                        var a = param[0];
                        return Curry._2(bind, f, (function (g) {
                                      return Curry._1(pure, Curry._1(g, a));
                                    }));
                      }
                    }));
      });
  }
  var include = Selective$CoreCategory.MakeCustom3({
        pure: pure,
        apply: apply$1,
        map: X.map,
        replace: X.replace,
        liftA2: X.liftA2,
        applyFirst: X.applyFirst,
        applySecond: X.applySecond,
        select: select$1
      });
  var pure$1 = include.pure;
  var $great$great$eq = Curry.__2(bind);
  var $great$great$tilde = function (m, n) {
    return Curry._2(bind, m, (function (param) {
                  return n;
                }));
  };
  var $great$eq$great = function (f, g, a) {
    return Curry._2(bind, Curry._1(f, a), g);
  };
  var MonadInfix = {
    $great$great$eq: $great$great$eq,
    $great$great$tilde: $great$great$tilde,
    $great$eq$great: $great$eq$great
  };
  var join = function (tt) {
    return Curry._2(bind, tt, (function (x) {
                  return x;
                }));
  };
  var sequenceM = function (ts) {
    var op = function (n, m) {
      return Curry._2(bind, m, (function (x) {
                    return Curry._2(bind, n, (function (xs) {
                                  return Curry._1(pure$1, /* :: */[
                                              x,
                                              xs
                                            ]);
                                }));
                  }));
    };
    return Belt_List.reduceReverse(ts, Curry._1(pure$1, /* [] */0), op);
  };
  var Undefined = Caml_exceptions.create("Monad-CoreCategory.MakeCustom3(X).Undefined");
  var forever = function (f) {
    var z = function (param) {
      throw Undefined;
    };
    var kcell = {
      contents: (function (x) {
          return x;
        })
    };
    var aux = function (param) {
      return Curry._1(kcell.contents, Curry._2(bind, Curry._1(f, (kcell.contents = (function (x) {
                              return x;
                            }), /* () */0)), chained));
    };
    var chained = function (param) {
      kcell.contents = aux;
      return z;
    };
    return aux(z);
  };
  var mapM = function (xs, f) {
    return sequenceM(Belt_List.map(xs, f));
  };
  var mapM_ = function (xs, f) {
    return Belt_List.reduceReverse(xs, Curry._1(pure$1, /* () */0), (function (accu, x) {
                  return Curry._2(bind, Curry._1(f, x), (function (param) {
                                return accu;
                              }));
                }));
  };
  return {
          map: include.map,
          replace: include.replace,
          $$void: include.$$void,
          FunctorInfix: include.FunctorInfix,
          $less$$great: include.$less$$great,
          $less$amp$great: include.$less$amp$great,
          $less$: include.$less$,
          $$great: include.$$great,
          apply: include.apply,
          applyFirst: include.applyFirst,
          applySecond: include.applySecond,
          liftA2: include.liftA2,
          ApplyInfix: include.ApplyInfix,
          $less$star$great: include.$less$star$great,
          $star$great: include.$star$great,
          $less$star: include.$less$star,
          $star$star: include.$star$star,
          liftA3: include.liftA3,
          liftA4: include.liftA4,
          liftA5: include.liftA5,
          merge: include.merge,
          pure: pure$1,
          when_: include.when_,
          unless: include.unless,
          select: include.select,
          SelectiveInfix: include.SelectiveInfix,
          $less$star$question: include.$less$star$question,
          $less$pipe$pipe$great: include.$less$pipe$pipe$great,
          $less$amp$amp$great: include.$less$amp$amp$great,
          orS: include.orS,
          andS: include.andS,
          whenS: include.whenS,
          branch: include.branch,
          ifS: include.ifS,
          fromOptionS: include.fromOptionS,
          anyS: include.anyS,
          allS: include.allS,
          whileS: include.whileS,
          bind: bind,
          MonadInfix: MonadInfix,
          $great$great$eq: $great$great$eq,
          $great$great$tilde: $great$great$tilde,
          $great$eq$great: $great$eq$great,
          join: join,
          forever: forever,
          sequenceM: sequenceM,
          mapM: mapM,
          mapM_: mapM_
        };
}

function MakeCustom1(X) {
  var pure = X.pure;
  var bind = X.bind;
  var apply = X.apply;
  var select = X.select;
  var apply$1;
  var exit = 0;
  if (typeof apply === "number" || apply[0] !== -198771759) {
    exit = 1;
  } else {
    apply$1 = apply[1];
  }
  if (exit === 1) {
    apply$1 = (function (t, f) {
        return Curry._2(bind, f, (function (g) {
                      return Curry._2(bind, t, (function (x) {
                                    return Curry._1(pure, Curry._1(g, x));
                                  }));
                    }));
      });
  }
  var select$1;
  var exit$1 = 0;
  if (typeof select === "number" || select[0] !== -198771759) {
    exit$1 = 1;
  } else {
    select$1 = select[1];
  }
  if (exit$1 === 1) {
    select$1 = (function (x, f) {
        return Curry._2(bind, x, (function (param) {
                      if (param.tag) {
                        return Curry._1(pure, param[0]);
                      } else {
                        var a = param[0];
                        return Curry._2(bind, f, (function (g) {
                                      return Curry._1(pure, Curry._1(g, a));
                                    }));
                      }
                    }));
      });
  }
  var include = Selective$CoreCategory.MakeCustom3({
        pure: pure,
        apply: apply$1,
        map: X.map,
        replace: X.replace,
        liftA2: X.liftA2,
        applyFirst: X.applyFirst,
        applySecond: X.applySecond,
        select: select$1
      });
  var pure$1 = include.pure;
  var $great$great$eq = Curry.__2(bind);
  var $great$great$tilde = function (m, n) {
    return Curry._2(bind, m, (function (param) {
                  return n;
                }));
  };
  var $great$eq$great = function (f, g, a) {
    return Curry._2(bind, Curry._1(f, a), g);
  };
  var MonadInfix = {
    $great$great$eq: $great$great$eq,
    $great$great$tilde: $great$great$tilde,
    $great$eq$great: $great$eq$great
  };
  var join = function (tt) {
    return Curry._2(bind, tt, (function (x) {
                  return x;
                }));
  };
  var sequenceM = function (ts) {
    var op = function (n, m) {
      return Curry._2(bind, m, (function (x) {
                    return Curry._2(bind, n, (function (xs) {
                                  return Curry._1(pure$1, /* :: */[
                                              x,
                                              xs
                                            ]);
                                }));
                  }));
    };
    return Belt_List.reduceReverse(ts, Curry._1(pure$1, /* [] */0), op);
  };
  var Undefined = Caml_exceptions.create("Monad-CoreCategory.MakeCustom3(X).Undefined");
  var forever = function (f) {
    var z = function (param) {
      throw Undefined;
    };
    var kcell = {
      contents: (function (x) {
          return x;
        })
    };
    var aux = function (param) {
      return Curry._1(kcell.contents, Curry._2(bind, Curry._1(f, (kcell.contents = (function (x) {
                              return x;
                            }), /* () */0)), chained));
    };
    var chained = function (param) {
      kcell.contents = aux;
      return z;
    };
    return aux(z);
  };
  var mapM = function (xs, f) {
    return sequenceM(Belt_List.map(xs, f));
  };
  var mapM_ = function (xs, f) {
    return Belt_List.reduceReverse(xs, Curry._1(pure$1, /* () */0), (function (accu, x) {
                  return Curry._2(bind, Curry._1(f, x), (function (param) {
                                return accu;
                              }));
                }));
  };
  return {
          map: include.map,
          replace: include.replace,
          $$void: include.$$void,
          FunctorInfix: include.FunctorInfix,
          $less$$great: include.$less$$great,
          $less$amp$great: include.$less$amp$great,
          $less$: include.$less$,
          $$great: include.$$great,
          apply: include.apply,
          liftA2: include.liftA2,
          applyFirst: include.applyFirst,
          applySecond: include.applySecond,
          ApplyInfix: include.ApplyInfix,
          $less$star$great: include.$less$star$great,
          $star$great: include.$star$great,
          $less$star: include.$less$star,
          $star$star: include.$star$star,
          liftA3: include.liftA3,
          liftA4: include.liftA4,
          liftA5: include.liftA5,
          merge: include.merge,
          pure: pure$1,
          when_: include.when_,
          unless: include.unless,
          select: include.select,
          SelectiveInfix: include.SelectiveInfix,
          $less$star$question: include.$less$star$question,
          $less$pipe$pipe$great: include.$less$pipe$pipe$great,
          $less$amp$amp$great: include.$less$amp$amp$great,
          orS: include.orS,
          andS: include.andS,
          whenS: include.whenS,
          branch: include.branch,
          ifS: include.ifS,
          fromOptionS: include.fromOptionS,
          anyS: include.anyS,
          allS: include.allS,
          whileS: include.whileS,
          bind: bind,
          MonadInfix: MonadInfix,
          $great$great$eq: $great$great$eq,
          $great$great$tilde: $great$great$tilde,
          $great$eq$great: $great$eq$great,
          join: join,
          forever: forever,
          sequenceM: sequenceM,
          mapM: mapM,
          mapM_: mapM_
        };
}

function Make3(X) {
  var pure = X.pure;
  var bind = X.bind;
  var apply;
  var exit = 0;
  exit = 1;
  if (exit === 1) {
    apply = (function (t, f) {
        return Curry._2(bind, f, (function (g) {
                      return Curry._2(bind, t, (function (x) {
                                    return Curry._1(pure, Curry._1(g, x));
                                  }));
                    }));
      });
  }
  var select;
  var exit$1 = 0;
  exit$1 = 1;
  if (exit$1 === 1) {
    select = (function (x, f) {
        return Curry._2(bind, x, (function (param) {
                      if (param.tag) {
                        return Curry._1(pure, param[0]);
                      } else {
                        var a = param[0];
                        return Curry._2(bind, f, (function (g) {
                                      return Curry._1(pure, Curry._1(g, a));
                                    }));
                      }
                    }));
      });
  }
  var include = Selective$CoreCategory.MakeCustom3({
        pure: pure,
        apply: apply,
        map: /* Derived */-684824643,
        replace: /* Derived */-684824643,
        liftA2: /* Derived */-684824643,
        applyFirst: /* Derived */-684824643,
        applySecond: /* Derived */-684824643,
        select: select
      });
  var pure$1 = include.pure;
  var $great$great$eq = Curry.__2(bind);
  var $great$great$tilde = function (m, n) {
    return Curry._2(bind, m, (function (param) {
                  return n;
                }));
  };
  var $great$eq$great = function (f, g, a) {
    return Curry._2(bind, Curry._1(f, a), g);
  };
  var MonadInfix = {
    $great$great$eq: $great$great$eq,
    $great$great$tilde: $great$great$tilde,
    $great$eq$great: $great$eq$great
  };
  var join = function (tt) {
    return Curry._2(bind, tt, (function (x) {
                  return x;
                }));
  };
  var sequenceM = function (ts) {
    var op = function (n, m) {
      return Curry._2(bind, m, (function (x) {
                    return Curry._2(bind, n, (function (xs) {
                                  return Curry._1(pure$1, /* :: */[
                                              x,
                                              xs
                                            ]);
                                }));
                  }));
    };
    return Belt_List.reduceReverse(ts, Curry._1(pure$1, /* [] */0), op);
  };
  var Undefined = Caml_exceptions.create("Monad-CoreCategory.MakeCustom3(X).Undefined");
  var forever = function (f) {
    var z = function (param) {
      throw Undefined;
    };
    var kcell = {
      contents: (function (x) {
          return x;
        })
    };
    var aux = function (param) {
      return Curry._1(kcell.contents, Curry._2(bind, Curry._1(f, (kcell.contents = (function (x) {
                              return x;
                            }), /* () */0)), chained));
    };
    var chained = function (param) {
      kcell.contents = aux;
      return z;
    };
    return aux(z);
  };
  var mapM = function (xs, f) {
    return sequenceM(Belt_List.map(xs, f));
  };
  var mapM_ = function (xs, f) {
    return Belt_List.reduceReverse(xs, Curry._1(pure$1, /* () */0), (function (accu, x) {
                  return Curry._2(bind, Curry._1(f, x), (function (param) {
                                return accu;
                              }));
                }));
  };
  return {
          map: include.map,
          replace: include.replace,
          $$void: include.$$void,
          FunctorInfix: include.FunctorInfix,
          $less$$great: include.$less$$great,
          $less$amp$great: include.$less$amp$great,
          $less$: include.$less$,
          $$great: include.$$great,
          apply: include.apply,
          applyFirst: include.applyFirst,
          applySecond: include.applySecond,
          liftA2: include.liftA2,
          ApplyInfix: include.ApplyInfix,
          $less$star$great: include.$less$star$great,
          $star$great: include.$star$great,
          $less$star: include.$less$star,
          $star$star: include.$star$star,
          liftA3: include.liftA3,
          liftA4: include.liftA4,
          liftA5: include.liftA5,
          merge: include.merge,
          pure: pure$1,
          when_: include.when_,
          unless: include.unless,
          select: include.select,
          SelectiveInfix: include.SelectiveInfix,
          $less$star$question: include.$less$star$question,
          $less$pipe$pipe$great: include.$less$pipe$pipe$great,
          $less$amp$amp$great: include.$less$amp$amp$great,
          orS: include.orS,
          andS: include.andS,
          whenS: include.whenS,
          branch: include.branch,
          ifS: include.ifS,
          fromOptionS: include.fromOptionS,
          anyS: include.anyS,
          allS: include.allS,
          whileS: include.whileS,
          bind: bind,
          MonadInfix: MonadInfix,
          $great$great$eq: $great$great$eq,
          $great$great$tilde: $great$great$tilde,
          $great$eq$great: $great$eq$great,
          join: join,
          forever: forever,
          sequenceM: sequenceM,
          mapM: mapM,
          mapM_: mapM_
        };
}

function Make2(X) {
  var pure = X.pure;
  var bind = X.bind;
  var apply;
  var exit = 0;
  exit = 1;
  if (exit === 1) {
    apply = (function (t, f) {
        return Curry._2(bind, f, (function (g) {
                      return Curry._2(bind, t, (function (x) {
                                    return Curry._1(pure, Curry._1(g, x));
                                  }));
                    }));
      });
  }
  var select;
  var exit$1 = 0;
  exit$1 = 1;
  if (exit$1 === 1) {
    select = (function (x, f) {
        return Curry._2(bind, x, (function (param) {
                      if (param.tag) {
                        return Curry._1(pure, param[0]);
                      } else {
                        var a = param[0];
                        return Curry._2(bind, f, (function (g) {
                                      return Curry._1(pure, Curry._1(g, a));
                                    }));
                      }
                    }));
      });
  }
  var include = Selective$CoreCategory.MakeCustom3({
        pure: pure,
        apply: apply,
        map: /* Derived */-684824643,
        replace: /* Derived */-684824643,
        liftA2: /* Derived */-684824643,
        applyFirst: /* Derived */-684824643,
        applySecond: /* Derived */-684824643,
        select: select
      });
  var pure$1 = include.pure;
  var $great$great$eq = Curry.__2(bind);
  var $great$great$tilde = function (m, n) {
    return Curry._2(bind, m, (function (param) {
                  return n;
                }));
  };
  var $great$eq$great = function (f, g, a) {
    return Curry._2(bind, Curry._1(f, a), g);
  };
  var MonadInfix = {
    $great$great$eq: $great$great$eq,
    $great$great$tilde: $great$great$tilde,
    $great$eq$great: $great$eq$great
  };
  var join = function (tt) {
    return Curry._2(bind, tt, (function (x) {
                  return x;
                }));
  };
  var sequenceM = function (ts) {
    var op = function (n, m) {
      return Curry._2(bind, m, (function (x) {
                    return Curry._2(bind, n, (function (xs) {
                                  return Curry._1(pure$1, /* :: */[
                                              x,
                                              xs
                                            ]);
                                }));
                  }));
    };
    return Belt_List.reduceReverse(ts, Curry._1(pure$1, /* [] */0), op);
  };
  var Undefined = Caml_exceptions.create("Monad-CoreCategory.MakeCustom3(X).Undefined");
  var forever = function (f) {
    var z = function (param) {
      throw Undefined;
    };
    var kcell = {
      contents: (function (x) {
          return x;
        })
    };
    var aux = function (param) {
      return Curry._1(kcell.contents, Curry._2(bind, Curry._1(f, (kcell.contents = (function (x) {
                              return x;
                            }), /* () */0)), chained));
    };
    var chained = function (param) {
      kcell.contents = aux;
      return z;
    };
    return aux(z);
  };
  var mapM = function (xs, f) {
    return sequenceM(Belt_List.map(xs, f));
  };
  var mapM_ = function (xs, f) {
    return Belt_List.reduceReverse(xs, Curry._1(pure$1, /* () */0), (function (accu, x) {
                  return Curry._2(bind, Curry._1(f, x), (function (param) {
                                return accu;
                              }));
                }));
  };
  return {
          map: include.map,
          replace: include.replace,
          $$void: include.$$void,
          FunctorInfix: include.FunctorInfix,
          $less$$great: include.$less$$great,
          $less$amp$great: include.$less$amp$great,
          $less$: include.$less$,
          $$great: include.$$great,
          apply: include.apply,
          applyFirst: include.applyFirst,
          applySecond: include.applySecond,
          liftA2: include.liftA2,
          ApplyInfix: include.ApplyInfix,
          $less$star$great: include.$less$star$great,
          $star$great: include.$star$great,
          $less$star: include.$less$star,
          $star$star: include.$star$star,
          liftA3: include.liftA3,
          liftA4: include.liftA4,
          liftA5: include.liftA5,
          merge: include.merge,
          pure: pure$1,
          when_: include.when_,
          unless: include.unless,
          select: include.select,
          SelectiveInfix: include.SelectiveInfix,
          $less$star$question: include.$less$star$question,
          $less$pipe$pipe$great: include.$less$pipe$pipe$great,
          $less$amp$amp$great: include.$less$amp$amp$great,
          orS: include.orS,
          andS: include.andS,
          whenS: include.whenS,
          branch: include.branch,
          ifS: include.ifS,
          fromOptionS: include.fromOptionS,
          anyS: include.anyS,
          allS: include.allS,
          whileS: include.whileS,
          bind: bind,
          MonadInfix: MonadInfix,
          $great$great$eq: $great$great$eq,
          $great$great$tilde: $great$great$tilde,
          $great$eq$great: $great$eq$great,
          join: join,
          forever: forever,
          sequenceM: sequenceM,
          mapM: mapM,
          mapM_: mapM_
        };
}

function Make1(X) {
  var pure = X.pure;
  var bind = X.bind;
  var apply;
  var exit = 0;
  exit = 1;
  if (exit === 1) {
    apply = (function (t, f) {
        return Curry._2(bind, f, (function (g) {
                      return Curry._2(bind, t, (function (x) {
                                    return Curry._1(pure, Curry._1(g, x));
                                  }));
                    }));
      });
  }
  var select;
  var exit$1 = 0;
  exit$1 = 1;
  if (exit$1 === 1) {
    select = (function (x, f) {
        return Curry._2(bind, x, (function (param) {
                      if (param.tag) {
                        return Curry._1(pure, param[0]);
                      } else {
                        var a = param[0];
                        return Curry._2(bind, f, (function (g) {
                                      return Curry._1(pure, Curry._1(g, a));
                                    }));
                      }
                    }));
      });
  }
  var include = Selective$CoreCategory.MakeCustom3({
        pure: pure,
        apply: apply,
        map: /* Derived */-684824643,
        replace: /* Derived */-684824643,
        liftA2: /* Derived */-684824643,
        applyFirst: /* Derived */-684824643,
        applySecond: /* Derived */-684824643,
        select: select
      });
  var pure$1 = include.pure;
  var $great$great$eq = Curry.__2(bind);
  var $great$great$tilde = function (m, n) {
    return Curry._2(bind, m, (function (param) {
                  return n;
                }));
  };
  var $great$eq$great = function (f, g, a) {
    return Curry._2(bind, Curry._1(f, a), g);
  };
  var MonadInfix = {
    $great$great$eq: $great$great$eq,
    $great$great$tilde: $great$great$tilde,
    $great$eq$great: $great$eq$great
  };
  var join = function (tt) {
    return Curry._2(bind, tt, (function (x) {
                  return x;
                }));
  };
  var sequenceM = function (ts) {
    var op = function (n, m) {
      return Curry._2(bind, m, (function (x) {
                    return Curry._2(bind, n, (function (xs) {
                                  return Curry._1(pure$1, /* :: */[
                                              x,
                                              xs
                                            ]);
                                }));
                  }));
    };
    return Belt_List.reduceReverse(ts, Curry._1(pure$1, /* [] */0), op);
  };
  var Undefined = Caml_exceptions.create("Monad-CoreCategory.MakeCustom3(X).Undefined");
  var forever = function (f) {
    var z = function (param) {
      throw Undefined;
    };
    var kcell = {
      contents: (function (x) {
          return x;
        })
    };
    var aux = function (param) {
      return Curry._1(kcell.contents, Curry._2(bind, Curry._1(f, (kcell.contents = (function (x) {
                              return x;
                            }), /* () */0)), chained));
    };
    var chained = function (param) {
      kcell.contents = aux;
      return z;
    };
    return aux(z);
  };
  var mapM = function (xs, f) {
    return sequenceM(Belt_List.map(xs, f));
  };
  var mapM_ = function (xs, f) {
    return Belt_List.reduceReverse(xs, Curry._1(pure$1, /* () */0), (function (accu, x) {
                  return Curry._2(bind, Curry._1(f, x), (function (param) {
                                return accu;
                              }));
                }));
  };
  return {
          map: include.map,
          replace: include.replace,
          $$void: include.$$void,
          FunctorInfix: include.FunctorInfix,
          $less$$great: include.$less$$great,
          $less$amp$great: include.$less$amp$great,
          $less$: include.$less$,
          $$great: include.$$great,
          apply: include.apply,
          liftA2: include.liftA2,
          applyFirst: include.applyFirst,
          applySecond: include.applySecond,
          ApplyInfix: include.ApplyInfix,
          $less$star$great: include.$less$star$great,
          $star$great: include.$star$great,
          $less$star: include.$less$star,
          $star$star: include.$star$star,
          liftA3: include.liftA3,
          liftA4: include.liftA4,
          liftA5: include.liftA5,
          merge: include.merge,
          pure: pure$1,
          when_: include.when_,
          unless: include.unless,
          select: include.select,
          SelectiveInfix: include.SelectiveInfix,
          $less$star$question: include.$less$star$question,
          $less$pipe$pipe$great: include.$less$pipe$pipe$great,
          $less$amp$amp$great: include.$less$amp$amp$great,
          orS: include.orS,
          andS: include.andS,
          whenS: include.whenS,
          branch: include.branch,
          ifS: include.ifS,
          fromOptionS: include.fromOptionS,
          anyS: include.anyS,
          allS: include.allS,
          whileS: include.whileS,
          bind: bind,
          MonadInfix: MonadInfix,
          $great$great$eq: $great$great$eq,
          $great$great$tilde: $great$great$tilde,
          $great$eq$great: $great$eq$great,
          join: join,
          forever: forever,
          sequenceM: sequenceM,
          mapM: mapM,
          mapM_: mapM_
        };
}

exports.S1_to_S2 = S1_to_S2;
exports.S2_to_S1 = S2_to_S1;
exports.S2_to_S3 = S2_to_S3;
exports.S3_to_S2 = S3_to_S2;
exports.MakeCustom1 = MakeCustom1;
exports.MakeCustom2 = MakeCustom2;
exports.MakeCustom3 = MakeCustom3;
exports.Make1 = Make1;
exports.Make2 = Make2;
exports.Make3 = Make3;
/* Selective-CoreCategory Not a pure module */
